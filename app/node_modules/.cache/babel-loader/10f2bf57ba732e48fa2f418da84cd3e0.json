{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect, useRef } from 'react';\nimport axios from 'axios';\nimport { getCurrentUserPlaylists, getPlaylistItems, getUserPlaylists } from '../spotify';\nimport { catchErrors } from '../utils'; //import { ChangeContext } from '../contexts/context';\n//top level function\n\n/*\r\nexport const MergePlaylists = () => {\r\n\r\n    const CurrentSongList = CurrentPlaylists();\r\n    //const UserSongList = UserPlaylists(\"lauravonbargen\");\r\n\r\n/*\r\n    const fetchData = async () => {\r\n        const { data1 } = await CurrentPlaylists();\r\n        const { data2 } = await UserPlaylists();\r\n    }\r\n\r\n    \r\n}\r\n*/\n\nfunction findOverlap(CurrentSongs, UserSongs) {\n  let overlap = [];\n\n  for (var i = 0; i < UserSongs.length; i++) {\n    const index = CurrentSongs.indexOf(UserSongs[i]);\n\n    if (index === -1) {\n      //means song is unique and should be added to overlap\n      overlap.push(CurrentSongs[index]);\n    }\n  }\n\n  console.log(\"Overlap: \" + overlap.length);\n}\n\nconst CsongIDs = [];\nconst UsongIDs = [];\nexport const Playlists = () => {\n  _s();\n\n  const [CplaylistsData, CsetPlaylistsData] = useState(null);\n  const [Cplaylists, CsetPlaylists] = useState(null);\n  const [UplaylistsData, UsetPlaylistsData] = useState(null);\n  const [Uplaylists, UsetPlaylists] = useState(null);\n  const [Go, setGo] = useState(false);\n  const [Merge, setMerge] = useState(false);\n  const CPIDS = []; //const CsongIDs = [];\n  //const CsongIDs = useRef([]);\n\n  const UPIDS = []; //const UsongIDs = [];\n  //const UsongIDs = useRef([]);\n\n  const Overlap = [];\n  useEffect(() => {\n    const fetchData = async () => {\n      const {\n        data\n      } = await getCurrentUserPlaylists();\n      CsetPlaylists(Cplaylists => [...(Cplaylists ? Cplaylists : []), ...data.items]);\n      CsetPlaylistsData(data);\n    };\n\n    catchErrors(fetchData());\n  }, []);\n  useEffect(() => {\n    if (!CplaylistsData) {\n      return;\n    } // Playlist endpoint only returns 20 playlists at a time, so we need to\n    // make sure we get ALL playlists by fetching the next set of playlists\n\n\n    const FetchMoreCData = async () => {\n      if (CplaylistsData.next) {\n        //as long as there is more data to be retrieved\n        const {\n          data\n        } = await axios.get(CplaylistsData.next);\n        CsetPlaylists(Cplaylists => [...(Cplaylists ? Cplaylists : []), ...data.items]);\n        CsetPlaylistsData(data);\n      } else {\n        //when all urls are retrieved\n        if (Cplaylists !== null) {\n          Object.entries(Cplaylists).forEach((key, value) => {\n            const PID = key[1][\"id\"];\n\n            if (!CPIDS.includes(PID)) {\n              CPIDS.push(PID);\n            }\n          });\n\n          for (var PID in CPIDS) {\n            const id = CPIDS[PID]; //data contains first 100 songs\n\n            let listData = await getPlaylistItems(id);\n            Object.entries(listData.data.items).forEach((key, value) => {\n              const songID = key[1][\"track\"][\"id\"];\n\n              if (!CsongIDs.includes(songID) && songID !== null) {\n                CsongIDs.push(songID);\n              }\n            }); //travel through \"next\" field of listData until end\n\n            while (listData.data.next) {\n              listData = await axios.get(listData.data.next);\n              Object.entries(listData.data.items).forEach((key, value) => {\n                const songID = key[1][\"track\"][\"id\"]; //console.log(\"C Before push conditional: \" + songID);\n\n                if (!CsongIDs.includes(songID) && songID !== null) {\n                  CsongIDs.push(songID); //console.log(\"C Push conditional: \" + songID);\n                }\n              }); //UsongIDs.push(listData.data.items);\n            }\n          }\n        }\n\n        console.log(\"go was set\");\n        console.log(\"C size: \" + CsongIDs.length);\n        setGo(true);\n      }\n    }; //catchErrors(fetchMoreData());\n\n\n    catchErrors(FetchMoreCData()); //catchErrors(fetchMoreUdata(fetchMoreData()));\n  }, [CplaylistsData]);\n  useEffect(() => {\n    const fetchData = async () => {\n      if (Go !== false) {\n        const {\n          data\n        } = await getUserPlaylists(\"1214092342\");\n        UsetPlaylists(Uplaylists => [...(Uplaylists ? Uplaylists : []), ...data.items]);\n        console.log(\"why is this called\");\n        UsetPlaylistsData(data);\n      }\n\n      ;\n    };\n\n    catchErrors(fetchData());\n  }, [Go]);\n  useEffect(() => {\n    //prevents running on initial render\n    if (!UplaylistsData) {\n      return;\n    }\n\n    const fetchMoreUData = async () => {\n      if (UplaylistsData.next) {\n        //as long as there is more data to be retrieved\n        const {\n          data\n        } = await axios.get(UplaylistsData.next);\n        UsetPlaylists(playlists => [...(playlists ? playlists : []), ...data.items]);\n        UsetPlaylistsData(data);\n      } else {\n        //when all urls are retrieved\n        if (Uplaylists !== null) {\n          Object.entries(Uplaylists).forEach((key, value) => {\n            const PID = key[1][\"id\"]; //console.log(PID);\n\n            if (!UPIDS.includes(PID)) {\n              UPIDS.push(PID);\n            }\n          });\n\n          for (var PID in UPIDS) {\n            const id = UPIDS[PID]; //data contains first 100 songs\n\n            let listData = await getPlaylistItems(id); //console.log(listData);\n            //handle first set of 100 songs\n\n            Object.entries(listData.data.items).forEach((key, value) => {\n              const songID = key[1][\"track\"][\"id\"];\n\n              if (!UsongIDs.includes(songID) && songID !== null) {\n                UsongIDs.push(songID);\n              }\n            }); //UsongIDs.push(listData.data.items);\n            //iterate through next field, saving songs\n\n            while (listData.data.next) {\n              listData = await axios.get(listData.data.next);\n              Object.entries(listData.data.items).forEach((key, value) => {\n                const songID = key[1][\"track\"][\"id\"]; //console.log(\"Before push conditional: \" + songID);\n\n                if (!UsongIDs.includes(songID) && songID !== null) {\n                  UsongIDs.push(songID); //console.log(\"Push conditional: \" + songID);\n                }\n              }); //UsongIDs.push(listData.data.items);\n            }\n          }\n\n          console.log(\"C len: \" + CsongIDs.length);\n          console.log(\"U len: \" + UsongIDs.length);\n\n          for (var i = 0; i < UsongIDs.length; i++) {//console.log(\"U ids: \" + UsongIDs[i]);\n          }\n\n          for (var i = 0; i < CsongIDs.length; i++) {//console.log(\"C ids: \" + CsongIDs[i]);\n          }\n\n          setMerge(true);\n        }\n      }\n    };\n\n    catchErrors(fetchMoreUData());\n  }, [UplaylistsData]);\n  useEffect(() => {\n    for (var i = 0; i < UsongIDs.length; i++) {\n      const index = CsongIDs.indexOf(UsongIDs[i]);\n      console.log(\"index: \" + index);\n\n      if (index === -1) {\n        //means song is unique and should be added to overlap\n        Overlap.push(CsongIDs[index]); //console.log(\"Pushed: \" + CsongIDs[index]);\n        //console.log(\"Overlap size: \" + Overlap.length);\n      }\n    }\n\n    if (Merge !== false) {\n      console.log(\"Overlapped:\" + Overlap.length);\n      console.log(\"C IDs: \" + CsongIDs.length);\n      console.log(\"U IDs: \" + UsongIDs.length);\n    }\n  }, [Merge]);\n};\n/*\r\nexport const CurrentPlaylists = () => {\r\n    const [playlistsData, setPlaylistsData] = useState(null);\r\n    const [playlists, setPlaylists] = useState(null);\r\n\r\n    const PIDS = [];\r\n    const songIDs = [];\r\n\r\n    useEffect(() =>  {\r\n    const fetchData = async () => {\r\n        const { data } = await getCurrentUserPlaylists();\r\n        \r\n        setPlaylists(playlists => ([\r\n        ...playlists ? playlists : [],\r\n        ...data.items\r\n        ]));\r\n        console.log(\"curlen\" + data.length);\r\n        setPlaylistsData(data);\r\n    };\r\n    catchErrors(fetchData());\r\n    }, []);\r\n\r\n    /*\r\n    useEffect(() => {\r\n        if (!playlistsData) {\r\n            return;\r\n        }\r\n\r\n        // Playlist endpoint only returns 20 playlists at a time, so we need to\r\n        // make sure we get ALL playlists by fetching the next set of playlists\r\n        const fetchMoreData = async () => {\r\n            if (playlistsData.next) {\r\n            //as long as there is more data to be retrieved\r\n            const { data } = await axios.get(playlistsData.next);\r\n            \r\n            setPlaylists(playlists => ([\r\n                ...playlists ? playlists : [],\r\n                ...data.items\r\n                ]));\r\n\r\n            setPlaylistsData(data);\r\n            } else {\r\n            //when all urls are retrieved\r\n            if(playlists !== null) { \r\n                Object.entries(playlists).forEach((key, value) => {\r\n                    const PID = key[1][\"id\"];\r\n                    //console.log(PID);\r\n                    if (!PIDS.includes(PID)) { \r\n                        PIDS.push(PID);\r\n                    }\r\n                });\r\n                \r\n                for (var PID in PIDS) {\r\n                    const id = PIDS[PID];\r\n                    \r\n                    //data contains first 100 songs\r\n                    let listData = await getPlaylistItems(id);\r\n                    //console.log(listData);\r\n                    \r\n                    Object.entries(listData.data.items).forEach((key, value) => {\r\n                        const songID = key[1][\"track\"][\"id\"];\r\n                        if (!songIDs.includes(songID) && songID !== null) { songIDs.push(songID); }\r\n                    });\r\n                    //console.log(\"before while: \" + i);\r\n                    songIDs.push(listData.data.items);\r\n                    \r\n                    while (listData.data.next) {\r\n\r\n                        listData = await axios.get(listData.data.next);\r\n                        \r\n                        Object.entries(listData.data.items).forEach((key, value) => {\r\n                            const songID = key[1][\"track\"][\"id\"];\r\n                            if (!songIDs.includes(songID) && songID !== null) { songIDs.push(songID); }\r\n                        })\r\n                        songIDs.push(listData.data.items);\r\n                        \r\n                    }\r\n\r\n                }\r\n                return songIDs;\r\n                \r\n            }\r\n            }\r\n        };\r\n        \r\n        catchErrors(fetchMoreData());\r\n\r\n        }, [playlistsData]);\r\n    \r\n};\r\n\r\nconst UserPlaylists = (userName) => {\r\n    const [playlistsData, setPlaylistsData] = useState(null);\r\n    const [playlists, setPlaylists] = useState(null);\r\n\r\n    const PIDS = [];\r\n    const songIDs = [];\r\n\r\n    useEffect(() =>  {\r\n    const fetchData = async () => {\r\n        const { data } = await getUserPlaylists(userName);\r\n        \r\n        setPlaylists(playlists => ([\r\n        ...playlists ? playlists : [],\r\n        ...data.items\r\n        ]));\r\n\r\n        setPlaylistsData(data);\r\n    };\r\n    catchErrors(fetchData());\r\n    }, []);\r\n\r\n\r\n    useEffect(() => {\r\n        if (!playlistsData) {\r\n            return;\r\n        }\r\n\r\n        // Playlist endpoint only returns 20 playlists at a time, so we need to\r\n        // make sure we get ALL playlists by fetching the next set of playlists\r\n        const fetchMoreData = async () => {\r\n            if (playlistsData.next) {\r\n            //as long as there is more data to be retrieved\r\n            const { data } = await axios.get(playlistsData.next);\r\n            \r\n            setPlaylists(playlists => ([\r\n                ...playlists ? playlists : [],\r\n                ...data.items\r\n                ]));\r\n\r\n            setPlaylistsData(data);\r\n            } else {\r\n            //when all urls are retrieved\r\n            if(playlists !== null) { \r\n                Object.entries(playlists).forEach((key, value) => {\r\n                    const PID = key[1][\"id\"];\r\n                    //console.log(PID);\r\n                    if (!PIDS.includes(PID)) { \r\n                        PIDS.push(PID);\r\n                    }\r\n                });\r\n                \r\n                for (var PID in PIDS) {\r\n                    const id = PIDS[PID];\r\n                    \r\n                    //data contains first 100 songs\r\n                    let listData = await getPlaylistItems(id);\r\n                    //console.log(listData);\r\n                    \r\n                    Object.entries(listData.data.items).forEach((key, value) => {\r\n                        const songID = key[1][\"track\"][\"id\"];\r\n                        if (!songIDs.includes(songID) && songID !== null) { songIDs.push(songID); }\r\n                    });\r\n                    //console.log(\"before while: \" + i);\r\n                    songIDs.push(listData.data.items);\r\n                    \r\n                    while (listData.data.next) {\r\n\r\n                        listData = await axios.get(listData.data.next);\r\n                        \r\n                        Object.entries(listData.data.items).forEach((key, value) => {\r\n                            const songID = key[1][\"track\"][\"id\"];\r\n                            if (!songIDs.includes(songID) && songID !== null) { songIDs.push(songID); }\r\n                        })\r\n                        songIDs.push(listData.data.items);\r\n                        \r\n                    }\r\n                }\r\n                \r\n                return songIDs;\r\n            }\r\n            }\r\n        };\r\n        \r\n        catchErrors(fetchMoreData());\r\n\r\n        }, [playlistsData]);\r\n};\r\n*/\n\n_s(Playlists, \"eMAlD2mePBT5+T/J+64Rb0Uq0NI=\");\n\n_c = Playlists;\n\nvar _c;\n\n$RefreshReg$(_c, \"Playlists\");","map":{"version":3,"names":["useState","useEffect","useRef","axios","getCurrentUserPlaylists","getPlaylistItems","getUserPlaylists","catchErrors","findOverlap","CurrentSongs","UserSongs","overlap","i","length","index","indexOf","push","console","log","CsongIDs","UsongIDs","Playlists","CplaylistsData","CsetPlaylistsData","Cplaylists","CsetPlaylists","UplaylistsData","UsetPlaylistsData","Uplaylists","UsetPlaylists","Go","setGo","Merge","setMerge","CPIDS","UPIDS","Overlap","fetchData","data","items","FetchMoreCData","next","get","Object","entries","forEach","key","value","PID","includes","id","listData","songID","fetchMoreUData","playlists"],"sources":["C:/Users/jrdue/Desktop/Current/app/src/dataCollecting/playlists.js"],"sourcesContent":["import { useState, useEffect, useRef } from 'react';\r\nimport axios from 'axios';\r\nimport { getCurrentUserPlaylists, getPlaylistItems, getUserPlaylists } from '../spotify';\r\nimport { catchErrors } from '../utils';\r\n//import { ChangeContext } from '../contexts/context';\r\n\r\n//top level function\r\n/*\r\nexport const MergePlaylists = () => {\r\n\r\n    const CurrentSongList = CurrentPlaylists();\r\n    //const UserSongList = UserPlaylists(\"lauravonbargen\");\r\n\r\n/*\r\n    const fetchData = async () => {\r\n        const { data1 } = await CurrentPlaylists();\r\n        const { data2 } = await UserPlaylists();\r\n    }\r\n\r\n    \r\n}\r\n*/\r\n\r\n\r\nfunction findOverlap(CurrentSongs, UserSongs) {\r\n    let overlap = [];\r\n\r\n    for (var i = 0; i < UserSongs.length; i++) {\r\n        const index = CurrentSongs.indexOf(UserSongs[i]);\r\n        if (index === -1) {\r\n            //means song is unique and should be added to overlap\r\n            overlap.push(CurrentSongs[index]);\r\n        }\r\n    }\r\n    console.log(\"Overlap: \" + overlap.length);\r\n}\r\n\r\nconst CsongIDs = [];\r\nconst UsongIDs = [];\r\n\r\nexport const Playlists = () => {\r\n    const [CplaylistsData, CsetPlaylistsData] = useState(null);\r\n    const [Cplaylists, CsetPlaylists] = useState(null);\r\n\r\n    const [UplaylistsData, UsetPlaylistsData] = useState(null);\r\n    const [Uplaylists, UsetPlaylists] = useState(null);\r\n\r\n    const [Go, setGo] = useState(false);\r\n    const [Merge, setMerge] = useState(false);\r\n\r\n    const CPIDS = [];\r\n    //const CsongIDs = [];\r\n    //const CsongIDs = useRef([]);\r\n\r\n    const UPIDS = [];\r\n    //const UsongIDs = [];\r\n    //const UsongIDs = useRef([]);\r\n\r\n    const Overlap = [];\r\n\r\n    useEffect(() =>  {\r\n    const fetchData = async () => {\r\n        const { data } = await getCurrentUserPlaylists();\r\n        \r\n        CsetPlaylists(Cplaylists => ([\r\n        ...Cplaylists ? Cplaylists : [],\r\n        ...data.items\r\n        ]));\r\n        \r\n        CsetPlaylistsData(data);\r\n    };\r\n    catchErrors(fetchData());\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        if (!CplaylistsData) {\r\n            return;\r\n        }\r\n\r\n        // Playlist endpoint only returns 20 playlists at a time, so we need to\r\n        // make sure we get ALL playlists by fetching the next set of playlists\r\n        const FetchMoreCData = async () => {\r\n            if (CplaylistsData.next) {\r\n                //as long as there is more data to be retrieved\r\n                const { data } = await axios.get(CplaylistsData.next);\r\n                \r\n                CsetPlaylists(Cplaylists => ([\r\n                    ...Cplaylists ? Cplaylists : [],\r\n                    ...data.items\r\n                    ]));\r\n\r\n                CsetPlaylistsData(data);\r\n            } else {\r\n            //when all urls are retrieved\r\n            if(Cplaylists !== null) { \r\n                Object.entries(Cplaylists).forEach((key, value) => {\r\n                    const PID = key[1][\"id\"];\r\n                    if (!CPIDS.includes(PID)) { \r\n                        CPIDS.push(PID);\r\n                    }\r\n                });\r\n                \r\n                for (var PID in CPIDS) {\r\n                    const id = CPIDS[PID];\r\n                    \r\n                    //data contains first 100 songs\r\n                    let listData = await getPlaylistItems(id);\r\n                    \r\n                    Object.entries(listData.data.items).forEach((key, value) => {\r\n                        const songID = key[1][\"track\"][\"id\"];\r\n                        if (!CsongIDs.includes(songID) && songID !== null) { CsongIDs.push(songID); }\r\n                    });\r\n\r\n                    \r\n                    //travel through \"next\" field of listData until end\r\n\r\n                    while (listData.data.next) {\r\n    \r\n                        listData = await axios.get(listData.data.next);\r\n                        \r\n                        Object.entries(listData.data.items).forEach((key, value) => {\r\n                            const songID = key[1][\"track\"][\"id\"];\r\n                            //console.log(\"C Before push conditional: \" + songID);\r\n                            if (!CsongIDs.includes(songID) && songID !== null) { \r\n                                CsongIDs.push(songID); \r\n                                //console.log(\"C Push conditional: \" + songID);\r\n                            }\r\n                        })\r\n                        //UsongIDs.push(listData.data.items);\r\n                    }\r\n                }\r\n            }\r\n            console.log(\"go was set\");\r\n            console.log(\"C size: \" + CsongIDs.length);\r\n            setGo(true);\r\n            }\r\n        };\r\n        \r\n        //catchErrors(fetchMoreData());\r\n    \r\n        catchErrors(FetchMoreCData());\r\n\r\n        //catchErrors(fetchMoreUdata(fetchMoreData()));\r\n    }, [CplaylistsData]);\r\n    \r\n    useEffect(() =>  {\r\n        const fetchData = async () => {\r\n            if (Go !== false) {\r\n                const { data } = await getUserPlaylists(\"1214092342\");\r\n                \r\n                UsetPlaylists(Uplaylists => ([\r\n                ...Uplaylists ? Uplaylists : [],\r\n                ...data.items\r\n                ]));\r\n                console.log(\"why is this called\");\r\n                UsetPlaylistsData(data);\r\n            };\r\n        }\r\n        catchErrors(fetchData());\r\n    }, [Go]);\r\n\r\n    useEffect(() => {\r\n        //prevents running on initial render\r\n        if (!UplaylistsData) { return; }\r\n\r\n        const fetchMoreUData = async () => {\r\n            if (UplaylistsData.next) {\r\n                //as long as there is more data to be retrieved\r\n                const { data } = await axios.get(UplaylistsData.next);\r\n                \r\n                UsetPlaylists(playlists => ([\r\n                    ...playlists ? playlists : [],\r\n                    ...data.items\r\n                    ]));\r\n    \r\n                UsetPlaylistsData(data);\r\n            } else {\r\n                //when all urls are retrieved\r\n                if(Uplaylists !== null) { \r\n                    Object.entries(Uplaylists).forEach((key, value) => {\r\n                        const PID = key[1][\"id\"];\r\n                        //console.log(PID);\r\n                        if (!UPIDS.includes(PID)) { \r\n                            UPIDS.push(PID);\r\n                        }\r\n                    });\r\n                    \r\n                    for (var PID in UPIDS) {\r\n                        const id = UPIDS[PID];\r\n                        \r\n                        //data contains first 100 songs\r\n                        let listData = await getPlaylistItems(id);\r\n                        //console.log(listData);\r\n                        \r\n\r\n                        //handle first set of 100 songs\r\n                        Object.entries(listData.data.items).forEach((key, value) => {\r\n                            const songID = key[1][\"track\"][\"id\"];\r\n                            if (!UsongIDs.includes(songID) && songID !== null) { UsongIDs.push(songID); }\r\n                        });\r\n\r\n                        //UsongIDs.push(listData.data.items);\r\n                        \r\n                        //iterate through next field, saving songs\r\n                        while (listData.data.next) {\r\n    \r\n                            listData = await axios.get(listData.data.next);\r\n                            \r\n                            Object.entries(listData.data.items).forEach((key, value) => {\r\n                                const songID = key[1][\"track\"][\"id\"];\r\n                                //console.log(\"Before push conditional: \" + songID);\r\n                                if (!UsongIDs.includes(songID) && songID !== null) { \r\n                                    UsongIDs.push(songID); \r\n                                    //console.log(\"Push conditional: \" + songID);\r\n                                }\r\n                            })\r\n                            //UsongIDs.push(listData.data.items);\r\n                        }\r\n                    } \r\n\r\n                    console.log(\"C len: \" + CsongIDs.length);\r\n                    console.log(\"U len: \" + UsongIDs.length);\r\n                    \r\n                    for (var i = 0; i < UsongIDs.length; i++) {\r\n                        //console.log(\"U ids: \" + UsongIDs[i]);\r\n                    }\r\n\r\n                    for (var i = 0; i < CsongIDs.length; i++) {\r\n                        //console.log(\"C ids: \" + CsongIDs[i]);\r\n                    }\r\n                    \r\n                    setMerge(true);\r\n                }\r\n            }\r\n        }\r\n\r\n        catchErrors(fetchMoreUData());\r\n    }, [UplaylistsData]);\r\n    \r\n    useEffect(() => {\r\n        for (var i = 0; i < UsongIDs.length; i++) {\r\n            const index = CsongIDs.indexOf(UsongIDs[i]);\r\n            console.log(\"index: \" + index);\r\n            if (index === -1) {\r\n                //means song is unique and should be added to overlap\r\n                Overlap.push(CsongIDs[index]);\r\n                //console.log(\"Pushed: \" + CsongIDs[index]);\r\n                //console.log(\"Overlap size: \" + Overlap.length);\r\n            }\r\n        }\r\n\r\n        if (Merge !== false) {\r\n            console.log(\"Overlapped:\" + Overlap.length);\r\n            console.log(\"C IDs: \" + CsongIDs.length);\r\n            console.log(\"U IDs: \" + UsongIDs.length);\r\n        }\r\n    }, [Merge]);\r\n    \r\n};\r\n\r\n\r\n/*\r\nexport const CurrentPlaylists = () => {\r\n    const [playlistsData, setPlaylistsData] = useState(null);\r\n    const [playlists, setPlaylists] = useState(null);\r\n\r\n    const PIDS = [];\r\n    const songIDs = [];\r\n\r\n    useEffect(() =>  {\r\n    const fetchData = async () => {\r\n        const { data } = await getCurrentUserPlaylists();\r\n        \r\n        setPlaylists(playlists => ([\r\n        ...playlists ? playlists : [],\r\n        ...data.items\r\n        ]));\r\n        console.log(\"curlen\" + data.length);\r\n        setPlaylistsData(data);\r\n    };\r\n    catchErrors(fetchData());\r\n    }, []);\r\n\r\n    /*\r\n    useEffect(() => {\r\n        if (!playlistsData) {\r\n            return;\r\n        }\r\n\r\n        // Playlist endpoint only returns 20 playlists at a time, so we need to\r\n        // make sure we get ALL playlists by fetching the next set of playlists\r\n        const fetchMoreData = async () => {\r\n            if (playlistsData.next) {\r\n            //as long as there is more data to be retrieved\r\n            const { data } = await axios.get(playlistsData.next);\r\n            \r\n            setPlaylists(playlists => ([\r\n                ...playlists ? playlists : [],\r\n                ...data.items\r\n                ]));\r\n\r\n            setPlaylistsData(data);\r\n            } else {\r\n            //when all urls are retrieved\r\n            if(playlists !== null) { \r\n                Object.entries(playlists).forEach((key, value) => {\r\n                    const PID = key[1][\"id\"];\r\n                    //console.log(PID);\r\n                    if (!PIDS.includes(PID)) { \r\n                        PIDS.push(PID);\r\n                    }\r\n                });\r\n                \r\n                for (var PID in PIDS) {\r\n                    const id = PIDS[PID];\r\n                    \r\n                    //data contains first 100 songs\r\n                    let listData = await getPlaylistItems(id);\r\n                    //console.log(listData);\r\n                    \r\n                    Object.entries(listData.data.items).forEach((key, value) => {\r\n                        const songID = key[1][\"track\"][\"id\"];\r\n                        if (!songIDs.includes(songID) && songID !== null) { songIDs.push(songID); }\r\n                    });\r\n                    //console.log(\"before while: \" + i);\r\n                    songIDs.push(listData.data.items);\r\n                    \r\n                    while (listData.data.next) {\r\n\r\n                        listData = await axios.get(listData.data.next);\r\n                        \r\n                        Object.entries(listData.data.items).forEach((key, value) => {\r\n                            const songID = key[1][\"track\"][\"id\"];\r\n                            if (!songIDs.includes(songID) && songID !== null) { songIDs.push(songID); }\r\n                        })\r\n                        songIDs.push(listData.data.items);\r\n                        \r\n                    }\r\n\r\n                }\r\n                return songIDs;\r\n                \r\n            }\r\n            }\r\n        };\r\n        \r\n        catchErrors(fetchMoreData());\r\n\r\n        }, [playlistsData]);\r\n    \r\n};\r\n\r\nconst UserPlaylists = (userName) => {\r\n    const [playlistsData, setPlaylistsData] = useState(null);\r\n    const [playlists, setPlaylists] = useState(null);\r\n\r\n    const PIDS = [];\r\n    const songIDs = [];\r\n\r\n    useEffect(() =>  {\r\n    const fetchData = async () => {\r\n        const { data } = await getUserPlaylists(userName);\r\n        \r\n        setPlaylists(playlists => ([\r\n        ...playlists ? playlists : [],\r\n        ...data.items\r\n        ]));\r\n\r\n        setPlaylistsData(data);\r\n    };\r\n    catchErrors(fetchData());\r\n    }, []);\r\n\r\n\r\n    useEffect(() => {\r\n        if (!playlistsData) {\r\n            return;\r\n        }\r\n\r\n        // Playlist endpoint only returns 20 playlists at a time, so we need to\r\n        // make sure we get ALL playlists by fetching the next set of playlists\r\n        const fetchMoreData = async () => {\r\n            if (playlistsData.next) {\r\n            //as long as there is more data to be retrieved\r\n            const { data } = await axios.get(playlistsData.next);\r\n            \r\n            setPlaylists(playlists => ([\r\n                ...playlists ? playlists : [],\r\n                ...data.items\r\n                ]));\r\n\r\n            setPlaylistsData(data);\r\n            } else {\r\n            //when all urls are retrieved\r\n            if(playlists !== null) { \r\n                Object.entries(playlists).forEach((key, value) => {\r\n                    const PID = key[1][\"id\"];\r\n                    //console.log(PID);\r\n                    if (!PIDS.includes(PID)) { \r\n                        PIDS.push(PID);\r\n                    }\r\n                });\r\n                \r\n                for (var PID in PIDS) {\r\n                    const id = PIDS[PID];\r\n                    \r\n                    //data contains first 100 songs\r\n                    let listData = await getPlaylistItems(id);\r\n                    //console.log(listData);\r\n                    \r\n                    Object.entries(listData.data.items).forEach((key, value) => {\r\n                        const songID = key[1][\"track\"][\"id\"];\r\n                        if (!songIDs.includes(songID) && songID !== null) { songIDs.push(songID); }\r\n                    });\r\n                    //console.log(\"before while: \" + i);\r\n                    songIDs.push(listData.data.items);\r\n                    \r\n                    while (listData.data.next) {\r\n\r\n                        listData = await axios.get(listData.data.next);\r\n                        \r\n                        Object.entries(listData.data.items).forEach((key, value) => {\r\n                            const songID = key[1][\"track\"][\"id\"];\r\n                            if (!songIDs.includes(songID) && songID !== null) { songIDs.push(songID); }\r\n                        })\r\n                        songIDs.push(listData.data.items);\r\n                        \r\n                    }\r\n                }\r\n                \r\n                return songIDs;\r\n            }\r\n            }\r\n        };\r\n        \r\n        catchErrors(fetchMoreData());\r\n\r\n        }, [playlistsData]);\r\n};\r\n*/"],"mappings":"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D,CAAC,EAAtC,EAA0C;MACtC,MAAME,KAAK,GAAGK,QAAQ,CAACJ,OAAT,CAAiBK,QAAQ,CAACR,CAAD,CAAzB,CAAd;MACAK,OAAO,CAACC,GAAR,CAAY,YAAYJ,KAAxB;;MACA,IAAIA,KAAK,KAAK,CAAC,CAAf,EAAkB;QACd;QACAsB,OAAO,CAACpB,IAAR,CAAaG,QAAQ,CAACL,KAAD,CAArB,EAFc,CAGd;QACA;MACH;IACJ;;IAED,IAAIkB,KAAK,KAAK,KAAd,EAAqB;MACjBf,OAAO,CAACC,GAAR,CAAY,gBAAgBkB,OAAO,CAACvB,MAApC;MACAI,OAAO,CAACC,GAAR,CAAY,YAAYC,QAAQ,CAACN,MAAjC;MACAI,OAAO,CAACC,GAAR,CAAY,YAAYE,QAAQ,CAACP,MAAjC;IACH;EACJ,CAjBQ,EAiBN,CAACmB,KAAD,CAjBM,CAAT;AAmBH,CA1NM;AA6NP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;GA/YaX,S;;KAAAA,S"},"metadata":{},"sourceType":"module"}