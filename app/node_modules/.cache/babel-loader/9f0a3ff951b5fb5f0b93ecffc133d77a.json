{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\nimport axios from 'axios';\nimport { getCurrentUserPlaylists, getPlaylistItems, getUserPlaylists } from '../spotify';\nimport { catchErrors } from '../utils'; //import { ChangeContext } from '../contexts/context';\n//top level function\n\nexport const MergePlaylists = () => {\n  const CurrentSongList = CurrentPlaylists(); //const UserSongList = UserPlaylists(\"lauravonbargen\");\n\n  /*\r\n      const fetchData = async () => {\r\n          const { data1 } = await CurrentPlaylists();\r\n          const { data2 } = await UserPlaylists();\r\n      }*/\n};\n_c = MergePlaylists;\n\nfunction findOverlap(CurrentSongs, UserSongs) {\n  let overlap = [];\n\n  for (var i = 0; i < UserSongs.length; i++) {\n    const index = CurrentSongs.indexOf(UserSongs[i]);\n\n    if (index === -1) {\n      //means song is unique and should be added to overlap\n      overlap.push(CurrentSongs[index]);\n    }\n  }\n\n  console.log(\"Overlap: \" + overlap.length);\n}\n\nexport const Playlists = () => {\n  _s();\n\n  const [CplaylistsData, CsetPlaylistsData] = useState(null);\n  const [Cplaylists, CsetPlaylists] = useState(null);\n  const [UplaylistsData, UsetPlaylistsData] = useState(null);\n  const [Uplaylists, UsetPlaylists] = useState(null);\n  const [Go, setGo] = useState(false);\n  const [Merge, setMerge] = useState(false);\n  const CPIDS = [];\n  const CsongIDs = [];\n  const UPIDS = [];\n  const UsongIDs = [];\n  const Overlap = [];\n  useEffect(() => {\n    const fetchData = async () => {\n      const {\n        Cdata\n      } = await getCurrentUserPlaylists();\n      CsetPlaylists(Cplaylists => [...(Cplaylists ? Cplaylists : []), ...Cdata.items]);\n      CsetPlaylistsData(Cdata);\n    };\n\n    catchErrors(fetchData());\n  }, []);\n  /*\r\n      useEffect(() =>  {\r\n          const fetchData = async () => {\r\n              const { Udata } = await getUserPlaylists(\"lauravonbargen\");\r\n              \r\n              UsetPlaylists(playlists => ([\r\n              ...playlists ? playlists : [],\r\n              ...Udata.items\r\n              ]));\r\n          };\r\n          catchErrors(fetchData());\r\n      }, []);\r\n  */\n\n  /*\r\n      useEffect(() => {\r\n          if (!CplaylistsData) {\r\n              return;\r\n          }\r\n  \r\n          // Playlist endpoint only returns 20 playlists at a time, so we need to\r\n          // make sure we get ALL playlists by fetching the next set of playlists\r\n          const fetchMoreCData = async () => {\r\n              console.log(\"C\");\r\n              if (CplaylistsData.next) {\r\n                  //as long as there is more data to be retrieved\r\n                  const { Cdata } = await axios.get(CplaylistsData.next);\r\n                  \r\n                  CsetPlaylists(Cplaylists => ([\r\n                      ...Cplaylists ? Cplaylists : [],\r\n                      ...Cdata.items\r\n                      ]));\r\n  \r\n                  CsetPlaylistsData(Cdata);\r\n              } else {\r\n              //when all urls are retrieved\r\n              if(Cplaylists !== null) { \r\n                  Object.entries(Cplaylists).forEach((key, value) => {\r\n                      const PID = key[1][\"id\"];\r\n                      if (!CPIDS.includes(PID)) { \r\n                          CPIDS.push(PID);\r\n                      }\r\n                  });\r\n                  \r\n                  for (var PID in CPIDS) {\r\n                      const id = CPIDS[PID];\r\n                      \r\n                      //data contains first 100 songs\r\n                      let listData = await getPlaylistItems(id);\r\n                      \r\n                      Object.entries(listData.data.items).forEach((key, value) => {\r\n                          const songID = key[1][\"track\"][\"id\"];\r\n                          if (!CsongIDs.includes(songID) && songID !== null) { CsongIDs.push(songID); }\r\n                      });\r\n  \r\n                      CsongIDs.push(listData.data.items);\r\n                      \r\n                      while (listData.data.next) {\r\n  \r\n                          listData = await axios.get(listData.data.next);\r\n                          \r\n                          Object.entries(listData.data.items).forEach((key, value) => {\r\n                              const songID = key[1][\"track\"][\"id\"];\r\n                              if (!CsongIDs.includes(songID) && songID !== null) { CsongIDs.push(songID); }\r\n                          })\r\n                          \r\n                          CsongIDs.push(listData.data.items);\r\n                          \r\n                      }\r\n  \r\n                  }\r\n  \r\n                  setGo(true);\r\n              }\r\n          }\r\n      };\r\n          \r\n          //catchErrors(fetchMoreData());\r\n      \r\n          catchErrors(fetchMoreCData());\r\n  \r\n          //catchErrors(fetchMoreUdata(fetchMoreData()));\r\n      }, [CplaylistsData]);\r\n      */\n\n  /*\r\n  useEffect(() => {\r\n      if (!UplaylistsData) { return; }\r\n        const fetchMoreUData = async () => {\r\n          console.log(\"Go\");\r\n          if (UplaylistsData.next) {\r\n              //as long as there is more data to be retrieved\r\n              const { data } = await axios.get(UplaylistsData.next);\r\n              \r\n              UsetPlaylists(playlists => ([\r\n                  ...playlists ? playlists : [],\r\n                  ...data.items\r\n                  ]));\r\n  \r\n              UsetPlaylistsData(data);\r\n              } else {\r\n              //when all urls are retrieved\r\n              if(Uplaylists !== null) { \r\n                  Object.entries(Uplaylists).forEach((key, value) => {\r\n                      const PID = key[1][\"id\"];\r\n                      //console.log(PID);\r\n                      if (!UPIDS.includes(PID)) { \r\n                          UPIDS.push(PID);\r\n                      }\r\n                  });\r\n                  \r\n                  for (var PID in UPIDS) {\r\n                        const id = UPIDS[PID];\r\n                      \r\n                      //data contains first 100 songs\r\n                      let listData = await getPlaylistItems(id);\r\n                      //console.log(listData);\r\n                      \r\n                      Object.entries(listData.data.items).forEach((key, value) => {\r\n                          const songID = key[1][\"track\"][\"id\"];\r\n                          if (!UsongIDs.includes(songID) && songID !== null) { UsongIDs.push(songID); }\r\n                      });\r\n                        UsongIDs.push(listData.data.items);\r\n                      \r\n                      while (listData.data.next) {\r\n  \r\n                          listData = await axios.get(listData.data.next);\r\n                          \r\n                          Object.entries(listData.data.items).forEach((key, value) => {\r\n                              const songID = key[1][\"track\"][\"id\"];\r\n                              if (!UsongIDs.includes(songID) && songID !== null) { UsongIDs.push(songID); }\r\n                          })\r\n                          UsongIDs.push(listData.data.items);\r\n                          \r\n                      }\r\n                  }  \r\n                    for (var i = 0; i < UsongIDs.length; i++) {\r\n                      const index = CsongIDs.indexOf(UsongIDs[i]);\r\n                      if (index === -1) {\r\n                          //means song is unique and should be added to overlap\r\n                          Overlap.push(CsongIDs[index]);\r\n                      }\r\n                  }\r\n                  \r\n                  setMerge(true);\r\n              }\r\n          }\r\n      }\r\n        catchErrors(fetchMoreUData());\r\n  }, [Go]);\r\n  \r\n  useEffect(() => {\r\n      console.log(\"Overlapped:\" + Overlap.length);\r\n  }, [Merge]);\r\n  */\n};\n\n_s(Playlists, \"zZ1Ol8KGgGO44dGu+uS74uk3qcs=\");\n\n_c2 = Playlists;\n\nconst CurrentPlaylists = () => {\n  _s2();\n\n  const [playlistsData, setPlaylistsData] = useState(null);\n  const [playlists, setPlaylists] = useState(null);\n  const PIDS = [];\n  const songIDs = [];\n  useEffect(() => {\n    const fetchData = async () => {\n      const {\n        data\n      } = await getCurrentUserPlaylists();\n      setPlaylists(playlists => [...(playlists ? playlists : []), ...data.items]);\n      setPlaylistsData(data);\n    };\n\n    catchErrors(fetchData());\n  }, []);\n  /*\r\n  useEffect(() => {\r\n      if (!playlistsData) {\r\n          return;\r\n      }\r\n        // Playlist endpoint only returns 20 playlists at a time, so we need to\r\n      // make sure we get ALL playlists by fetching the next set of playlists\r\n      const fetchMoreData = async () => {\r\n          if (playlistsData.next) {\r\n          //as long as there is more data to be retrieved\r\n          const { data } = await axios.get(playlistsData.next);\r\n          \r\n          setPlaylists(playlists => ([\r\n              ...playlists ? playlists : [],\r\n              ...data.items\r\n              ]));\r\n            setPlaylistsData(data);\r\n          } else {\r\n          //when all urls are retrieved\r\n          if(playlists !== null) { \r\n              Object.entries(playlists).forEach((key, value) => {\r\n                  const PID = key[1][\"id\"];\r\n                  //console.log(PID);\r\n                  if (!PIDS.includes(PID)) { \r\n                      PIDS.push(PID);\r\n                  }\r\n              });\r\n              \r\n              for (var PID in PIDS) {\r\n                  const id = PIDS[PID];\r\n                  \r\n                  //data contains first 100 songs\r\n                  let listData = await getPlaylistItems(id);\r\n                  //console.log(listData);\r\n                  \r\n                  Object.entries(listData.data.items).forEach((key, value) => {\r\n                      const songID = key[1][\"track\"][\"id\"];\r\n                      if (!songIDs.includes(songID) && songID !== null) { songIDs.push(songID); }\r\n                  });\r\n                  //console.log(\"before while: \" + i);\r\n                  songIDs.push(listData.data.items);\r\n                  \r\n                  while (listData.data.next) {\r\n                        listData = await axios.get(listData.data.next);\r\n                      \r\n                      Object.entries(listData.data.items).forEach((key, value) => {\r\n                          const songID = key[1][\"track\"][\"id\"];\r\n                          if (!songIDs.includes(songID) && songID !== null) { songIDs.push(songID); }\r\n                      })\r\n                      songIDs.push(listData.data.items);\r\n                      \r\n                  }\r\n                }\r\n              return songIDs;\r\n              \r\n          }\r\n          }\r\n      };\r\n      \r\n      catchErrors(fetchMoreData());\r\n        }, [playlistsData]);\r\n  */\n};\n\n_s2(CurrentPlaylists, \"9KuL9NetKwysi6XBa8mIxwC2pag=\");\n\n_c3 = CurrentPlaylists;\n\nconst UserPlaylists = userName => {\n  _s3();\n\n  const [playlistsData, setPlaylistsData] = useState(null);\n  const [playlists, setPlaylists] = useState(null);\n  const PIDS = [];\n  const songIDs = [];\n  useEffect(() => {\n    const fetchData = async () => {\n      const {\n        data\n      } = await getUserPlaylists(userName);\n      setPlaylists(playlists => [...(playlists ? playlists : []), ...data.items]);\n      setPlaylistsData(data);\n    };\n\n    catchErrors(fetchData());\n  }, []);\n  useEffect(() => {\n    if (!playlistsData) {\n      return;\n    } // Playlist endpoint only returns 20 playlists at a time, so we need to\n    // make sure we get ALL playlists by fetching the next set of playlists\n\n\n    const fetchMoreData = async () => {\n      if (playlistsData.next) {\n        //as long as there is more data to be retrieved\n        const {\n          data\n        } = await axios.get(playlistsData.next);\n        setPlaylists(playlists => [...(playlists ? playlists : []), ...data.items]);\n        setPlaylistsData(data);\n      } else {\n        //when all urls are retrieved\n        if (playlists !== null) {\n          Object.entries(playlists).forEach((key, value) => {\n            const PID = key[1][\"id\"]; //console.log(PID);\n\n            if (!PIDS.includes(PID)) {\n              PIDS.push(PID);\n            }\n          });\n\n          for (var PID in PIDS) {\n            const id = PIDS[PID]; //data contains first 100 songs\n\n            let listData = await getPlaylistItems(id); //console.log(listData);\n\n            Object.entries(listData.data.items).forEach((key, value) => {\n              const songID = key[1][\"track\"][\"id\"];\n\n              if (!songIDs.includes(songID) && songID !== null) {\n                songIDs.push(songID);\n              }\n            }); //console.log(\"before while: \" + i);\n\n            songIDs.push(listData.data.items);\n\n            while (listData.data.next) {\n              listData = await axios.get(listData.data.next);\n              Object.entries(listData.data.items).forEach((key, value) => {\n                const songID = key[1][\"track\"][\"id\"];\n\n                if (!songIDs.includes(songID) && songID !== null) {\n                  songIDs.push(songID);\n                }\n              });\n              songIDs.push(listData.data.items);\n            }\n          }\n\n          return songIDs;\n        }\n      }\n    };\n\n    catchErrors(fetchMoreData());\n  }, [playlistsData]);\n};\n\n_s3(UserPlaylists, \"7k+NFKyGxcUnGBIpi7HyuIISDKA=\");\n\n_c4 = UserPlaylists;\n\nvar _c, _c2, _c3, _c4;\n\n$RefreshReg$(_c, \"MergePlaylists\");\n$RefreshReg$(_c2, \"Playlists\");\n$RefreshReg$(_c3, \"CurrentPlaylists\");\n$RefreshReg$(_c4, \"UserPlaylists\");","map":{"version":3,"names":["useState","useEffect","axios","getCurrentUserPlaylists","getPlaylistItems","getUserPlaylists","catchErrors","MergePlaylists","CurrentSongList","CurrentPlaylists","findOverlap","CurrentSongs","UserSongs","overlap","i","length","index","indexOf","push","console","log","Playlists","CplaylistsData","CsetPlaylistsData","Cplaylists","CsetPlaylists","UplaylistsData","UsetPlaylistsData","Uplaylists","UsetPlaylists","Go","setGo","Merge","setMerge","CPIDS","CsongIDs","UPIDS","UsongIDs","Overlap","fetchData","Cdata","items","playlistsData","setPlaylistsData","playlists","setPlaylists","PIDS","songIDs","data","UserPlaylists","userName","fetchMoreData","next","get","Object","entries","forEach","key","value","PID","includes","id","listData","songID"],"sources":["C:/Users/jrdue/Desktop/Current/app/src/dataCollecting/playlists.js"],"sourcesContent":["import { useState, useEffect } from 'react';\r\nimport axios from 'axios';\r\nimport { getCurrentUserPlaylists, getPlaylistItems, getUserPlaylists } from '../spotify';\r\nimport { catchErrors } from '../utils';\r\n//import { ChangeContext } from '../contexts/context';\r\n\r\n//top level function\r\nexport const MergePlaylists = () => {\r\n\r\n    const CurrentSongList = CurrentPlaylists();\r\n    //const UserSongList = UserPlaylists(\"lauravonbargen\");\r\n\r\n/*\r\n    const fetchData = async () => {\r\n        const { data1 } = await CurrentPlaylists();\r\n        const { data2 } = await UserPlaylists();\r\n    }*/\r\n\r\n    \r\n}\r\n\r\nfunction findOverlap(CurrentSongs, UserSongs) {\r\n    let overlap = [];\r\n\r\n    for (var i = 0; i < UserSongs.length; i++) {\r\n        const index = CurrentSongs.indexOf(UserSongs[i]);\r\n        if (index === -1) {\r\n            //means song is unique and should be added to overlap\r\n            overlap.push(CurrentSongs[index]);\r\n        }\r\n    }\r\n    console.log(\"Overlap: \" + overlap.length);\r\n}\r\n\r\n\r\nexport const Playlists = () => {\r\n    const [CplaylistsData, CsetPlaylistsData] = useState(null);\r\n    const [Cplaylists, CsetPlaylists] = useState(null);\r\n\r\n    const [UplaylistsData, UsetPlaylistsData] = useState(null);\r\n    const [Uplaylists, UsetPlaylists] = useState(null);\r\n\r\n    const [Go, setGo] = useState(false);\r\n    const [Merge, setMerge] = useState(false);\r\n\r\n    const CPIDS = [];\r\n    const CsongIDs = [];\r\n\r\n    const UPIDS = [];\r\n    const UsongIDs = [];\r\n\r\n    const Overlap = [];\r\n\r\n    useEffect(() =>  {\r\n    const fetchData = async () => {\r\n        const { Cdata } = await getCurrentUserPlaylists();\r\n        \r\n        CsetPlaylists(Cplaylists => ([\r\n        ...Cplaylists ? Cplaylists : [],\r\n        ...Cdata.items\r\n        ]));\r\n\r\n        CsetPlaylistsData(Cdata);\r\n    };\r\n    catchErrors(fetchData());\r\n    }, []);\r\n/*\r\n    useEffect(() =>  {\r\n        const fetchData = async () => {\r\n            const { Udata } = await getUserPlaylists(\"lauravonbargen\");\r\n            \r\n            UsetPlaylists(playlists => ([\r\n            ...playlists ? playlists : [],\r\n            ...Udata.items\r\n            ]));\r\n        };\r\n        catchErrors(fetchData());\r\n    }, []);\r\n*/\r\n/*\r\n    useEffect(() => {\r\n        if (!CplaylistsData) {\r\n            return;\r\n        }\r\n\r\n        // Playlist endpoint only returns 20 playlists at a time, so we need to\r\n        // make sure we get ALL playlists by fetching the next set of playlists\r\n        const fetchMoreCData = async () => {\r\n            console.log(\"C\");\r\n            if (CplaylistsData.next) {\r\n                //as long as there is more data to be retrieved\r\n                const { Cdata } = await axios.get(CplaylistsData.next);\r\n                \r\n                CsetPlaylists(Cplaylists => ([\r\n                    ...Cplaylists ? Cplaylists : [],\r\n                    ...Cdata.items\r\n                    ]));\r\n\r\n                CsetPlaylistsData(Cdata);\r\n            } else {\r\n            //when all urls are retrieved\r\n            if(Cplaylists !== null) { \r\n                Object.entries(Cplaylists).forEach((key, value) => {\r\n                    const PID = key[1][\"id\"];\r\n                    if (!CPIDS.includes(PID)) { \r\n                        CPIDS.push(PID);\r\n                    }\r\n                });\r\n                \r\n                for (var PID in CPIDS) {\r\n                    const id = CPIDS[PID];\r\n                    \r\n                    //data contains first 100 songs\r\n                    let listData = await getPlaylistItems(id);\r\n                    \r\n                    Object.entries(listData.data.items).forEach((key, value) => {\r\n                        const songID = key[1][\"track\"][\"id\"];\r\n                        if (!CsongIDs.includes(songID) && songID !== null) { CsongIDs.push(songID); }\r\n                    });\r\n\r\n                    CsongIDs.push(listData.data.items);\r\n                    \r\n                    while (listData.data.next) {\r\n\r\n                        listData = await axios.get(listData.data.next);\r\n                        \r\n                        Object.entries(listData.data.items).forEach((key, value) => {\r\n                            const songID = key[1][\"track\"][\"id\"];\r\n                            if (!CsongIDs.includes(songID) && songID !== null) { CsongIDs.push(songID); }\r\n                        })\r\n                        \r\n                        CsongIDs.push(listData.data.items);\r\n                        \r\n                    }\r\n\r\n                }\r\n\r\n                setGo(true);\r\n            }\r\n        }\r\n    };\r\n        \r\n        //catchErrors(fetchMoreData());\r\n    \r\n        catchErrors(fetchMoreCData());\r\n\r\n        //catchErrors(fetchMoreUdata(fetchMoreData()));\r\n    }, [CplaylistsData]);\r\n    */\r\n    /*\r\n    useEffect(() => {\r\n        if (!UplaylistsData) { return; }\r\n\r\n        const fetchMoreUData = async () => {\r\n            console.log(\"Go\");\r\n            if (UplaylistsData.next) {\r\n                //as long as there is more data to be retrieved\r\n                const { data } = await axios.get(UplaylistsData.next);\r\n                \r\n                UsetPlaylists(playlists => ([\r\n                    ...playlists ? playlists : [],\r\n                    ...data.items\r\n                    ]));\r\n    \r\n                UsetPlaylistsData(data);\r\n                } else {\r\n                //when all urls are retrieved\r\n                if(Uplaylists !== null) { \r\n                    Object.entries(Uplaylists).forEach((key, value) => {\r\n                        const PID = key[1][\"id\"];\r\n                        //console.log(PID);\r\n                        if (!UPIDS.includes(PID)) { \r\n                            UPIDS.push(PID);\r\n                        }\r\n                    });\r\n                    \r\n                    for (var PID in UPIDS) {\r\n\r\n                        const id = UPIDS[PID];\r\n                        \r\n                        //data contains first 100 songs\r\n                        let listData = await getPlaylistItems(id);\r\n                        //console.log(listData);\r\n                        \r\n                        Object.entries(listData.data.items).forEach((key, value) => {\r\n                            const songID = key[1][\"track\"][\"id\"];\r\n                            if (!UsongIDs.includes(songID) && songID !== null) { UsongIDs.push(songID); }\r\n                        });\r\n\r\n                        UsongIDs.push(listData.data.items);\r\n                        \r\n                        while (listData.data.next) {\r\n    \r\n                            listData = await axios.get(listData.data.next);\r\n                            \r\n                            Object.entries(listData.data.items).forEach((key, value) => {\r\n                                const songID = key[1][\"track\"][\"id\"];\r\n                                if (!UsongIDs.includes(songID) && songID !== null) { UsongIDs.push(songID); }\r\n                            })\r\n                            UsongIDs.push(listData.data.items);\r\n                            \r\n                        }\r\n                    }  \r\n\r\n                    for (var i = 0; i < UsongIDs.length; i++) {\r\n                        const index = CsongIDs.indexOf(UsongIDs[i]);\r\n                        if (index === -1) {\r\n                            //means song is unique and should be added to overlap\r\n                            Overlap.push(CsongIDs[index]);\r\n                        }\r\n                    }\r\n                    \r\n                    setMerge(true);\r\n                }\r\n            }\r\n        }\r\n\r\n        catchErrors(fetchMoreUData());\r\n    }, [Go]);\r\n    \r\n    useEffect(() => {\r\n        console.log(\"Overlapped:\" + Overlap.length);\r\n    }, [Merge]);\r\n    */\r\n};\r\n\r\n\r\n\r\nconst CurrentPlaylists = () => {\r\n    const [playlistsData, setPlaylistsData] = useState(null);\r\n    const [playlists, setPlaylists] = useState(null);\r\n\r\n    const PIDS = [];\r\n    const songIDs = [];\r\n\r\n    useEffect(() =>  {\r\n    const fetchData = async () => {\r\n        const { data } = await getCurrentUserPlaylists();\r\n        \r\n        setPlaylists(playlists => ([\r\n        ...playlists ? playlists : [],\r\n        ...data.items\r\n        ]));\r\n\r\n        setPlaylistsData(data);\r\n    };\r\n    catchErrors(fetchData());\r\n    }, []);\r\n\r\n    /*\r\n    useEffect(() => {\r\n        if (!playlistsData) {\r\n            return;\r\n        }\r\n\r\n        // Playlist endpoint only returns 20 playlists at a time, so we need to\r\n        // make sure we get ALL playlists by fetching the next set of playlists\r\n        const fetchMoreData = async () => {\r\n            if (playlistsData.next) {\r\n            //as long as there is more data to be retrieved\r\n            const { data } = await axios.get(playlistsData.next);\r\n            \r\n            setPlaylists(playlists => ([\r\n                ...playlists ? playlists : [],\r\n                ...data.items\r\n                ]));\r\n\r\n            setPlaylistsData(data);\r\n            } else {\r\n            //when all urls are retrieved\r\n            if(playlists !== null) { \r\n                Object.entries(playlists).forEach((key, value) => {\r\n                    const PID = key[1][\"id\"];\r\n                    //console.log(PID);\r\n                    if (!PIDS.includes(PID)) { \r\n                        PIDS.push(PID);\r\n                    }\r\n                });\r\n                \r\n                for (var PID in PIDS) {\r\n                    const id = PIDS[PID];\r\n                    \r\n                    //data contains first 100 songs\r\n                    let listData = await getPlaylistItems(id);\r\n                    //console.log(listData);\r\n                    \r\n                    Object.entries(listData.data.items).forEach((key, value) => {\r\n                        const songID = key[1][\"track\"][\"id\"];\r\n                        if (!songIDs.includes(songID) && songID !== null) { songIDs.push(songID); }\r\n                    });\r\n                    //console.log(\"before while: \" + i);\r\n                    songIDs.push(listData.data.items);\r\n                    \r\n                    while (listData.data.next) {\r\n\r\n                        listData = await axios.get(listData.data.next);\r\n                        \r\n                        Object.entries(listData.data.items).forEach((key, value) => {\r\n                            const songID = key[1][\"track\"][\"id\"];\r\n                            if (!songIDs.includes(songID) && songID !== null) { songIDs.push(songID); }\r\n                        })\r\n                        songIDs.push(listData.data.items);\r\n                        \r\n                    }\r\n\r\n                }\r\n                return songIDs;\r\n                \r\n            }\r\n            }\r\n        };\r\n        \r\n        catchErrors(fetchMoreData());\r\n\r\n        }, [playlistsData]);\r\n    */\r\n};\r\n\r\nconst UserPlaylists = (userName) => {\r\n    const [playlistsData, setPlaylistsData] = useState(null);\r\n    const [playlists, setPlaylists] = useState(null);\r\n\r\n    const PIDS = [];\r\n    const songIDs = [];\r\n\r\n    useEffect(() =>  {\r\n    const fetchData = async () => {\r\n        const { data } = await getUserPlaylists(userName);\r\n        \r\n        setPlaylists(playlists => ([\r\n        ...playlists ? playlists : [],\r\n        ...data.items\r\n        ]));\r\n\r\n        setPlaylistsData(data);\r\n    };\r\n    catchErrors(fetchData());\r\n    }, []);\r\n\r\n\r\n    useEffect(() => {\r\n        if (!playlistsData) {\r\n            return;\r\n        }\r\n\r\n        // Playlist endpoint only returns 20 playlists at a time, so we need to\r\n        // make sure we get ALL playlists by fetching the next set of playlists\r\n        const fetchMoreData = async () => {\r\n            if (playlistsData.next) {\r\n            //as long as there is more data to be retrieved\r\n            const { data } = await axios.get(playlistsData.next);\r\n            \r\n            setPlaylists(playlists => ([\r\n                ...playlists ? playlists : [],\r\n                ...data.items\r\n                ]));\r\n\r\n            setPlaylistsData(data);\r\n            } else {\r\n            //when all urls are retrieved\r\n            if(playlists !== null) { \r\n                Object.entries(playlists).forEach((key, value) => {\r\n                    const PID = key[1][\"id\"];\r\n                    //console.log(PID);\r\n                    if (!PIDS.includes(PID)) { \r\n                        PIDS.push(PID);\r\n                    }\r\n                });\r\n                \r\n                for (var PID in PIDS) {\r\n                    const id = PIDS[PID];\r\n                    \r\n                    //data contains first 100 songs\r\n                    let listData = await getPlaylistItems(id);\r\n                    //console.log(listData);\r\n                    \r\n                    Object.entries(listData.data.items).forEach((key, value) => {\r\n                        const songID = key[1][\"track\"][\"id\"];\r\n                        if (!songIDs.includes(songID) && songID !== null) { songIDs.push(songID); }\r\n                    });\r\n                    //console.log(\"before while: \" + i);\r\n                    songIDs.push(listData.data.items);\r\n                    \r\n                    while (listData.data.next) {\r\n\r\n                        listData = await axios.get(listData.data.next);\r\n                        \r\n                        Object.entries(listData.data.items).forEach((key, value) => {\r\n                            const songID = key[1][\"track\"][\"id\"];\r\n                            if (!songIDs.includes(songID) && songID !== null) { songIDs.push(songID); }\r\n                        })\r\n                        songIDs.push(listData.data.items);\r\n                        \r\n                    }\r\n                }\r\n                \r\n                return songIDs;\r\n            }\r\n            }\r\n        };\r\n        \r\n        catchErrors(fetchMoreData());\r\n\r\n        }, [playlistsData]);\r\n};"],"mappings":";;;;AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,SAASC,uBAAT,EAAkCC,gBAAlC,EAAoDC,gBAApD,QAA4E,YAA5E;AACA,SAASC,WAAT,QAA4B,UAA5B,C,CACA;AAEA;;AACA,OAAO,MAAMC,cAAc,GAAG,MAAM;EAEhC,MAAMC,eAAe,GAAGC,gBAAgB,EAAxC,CAFgC,CAGhC;;EAEJ;AACA;AACA;AACA;AACA;AAGC,CAZM;KAAMF,c;;AAcb,SAASG,WAAT,CAAqBC,YAArB,EAAmCC,SAAnC,EAA8C;EAC1C,IAAIC,OAAO,GAAG,EAAd;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAAS,CAACG,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;IACvC,MAAME,KAAK,GAAGL,YAAY,CAACM,OAAb,CAAqBL,SAAS,CAACE,CAAD,CAA9B,CAAd;;IACA,IAAIE,KAAK,KAAK,CAAC,CAAf,EAAkB;MACd;MACAH,OAAO,CAACK,IAAR,CAAaP,YAAY,CAACK,KAAD,CAAzB;IACH;EACJ;;EACDG,OAAO,CAACC,GAAR,CAAY,cAAcP,OAAO,CAACE,MAAlC;AACH;;AAGD,OAAO,MAAMM,SAAS,GAAG,MAAM;EAAA;;EAC3B,MAAM,CAACC,cAAD,EAAiBC,iBAAjB,IAAsCvB,QAAQ,CAAC,IAAD,CAApD;EACA,MAAM,CAACwB,UAAD,EAAaC,aAAb,IAA8BzB,QAAQ,CAAC,IAAD,CAA5C;EAEA,MAAM,CAAC0B,cAAD,EAAiBC,iBAAjB,IAAsC3B,QAAQ,CAAC,IAAD,CAApD;EACA,MAAM,CAAC4B,UAAD,EAAaC,aAAb,IAA8B7B,QAAQ,CAAC,IAAD,CAA5C;EAEA,MAAM,CAAC8B,EAAD,EAAKC,KAAL,IAAc/B,QAAQ,CAAC,KAAD,CAA5B;EACA,MAAM,CAACgC,KAAD,EAAQC,QAAR,IAAoBjC,QAAQ,CAAC,KAAD,CAAlC;EAEA,MAAMkC,KAAK,GAAG,EAAd;EACA,MAAMC,QAAQ,GAAG,EAAjB;EAEA,MAAMC,KAAK,GAAG,EAAd;EACA,MAAMC,QAAQ,GAAG,EAAjB;EAEA,MAAMC,OAAO,GAAG,EAAhB;EAEArC,SAAS,CAAC,MAAO;IACjB,MAAMsC,SAAS,GAAG,YAAY;MAC1B,MAAM;QAAEC;MAAF,IAAY,MAAMrC,uBAAuB,EAA/C;MAEAsB,aAAa,CAACD,UAAU,IAAK,CAC7B,IAAGA,UAAU,GAAGA,UAAH,GAAgB,EAA7B,CAD6B,EAE7B,GAAGgB,KAAK,CAACC,KAFoB,CAAhB,CAAb;MAKAlB,iBAAiB,CAACiB,KAAD,CAAjB;IACH,CATD;;IAUAlC,WAAW,CAACiC,SAAS,EAAV,CAAX;EACC,CAZQ,EAYN,EAZM,CAAT;EAaJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMC,CA7LM;;GAAMlB,S;;MAAAA,S;;AAiMb,MAAMZ,gBAAgB,GAAG,MAAM;EAAA;;EAC3B,MAAM,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"},"metadata":{},"sourceType":"module"}